# -*- coding: utf-8 -*-
"""Tellagorla_IT533_Lab01.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14-Xjr88ghwvchTYhxuvJq8ZYRORgBqmg

***1.Lets know about the structure of the data first. The database is belong to Amazon toy products which contains price, stock, customer / product reviews, status, product description and information. This is all about series of records which called as structure of data.***
"""

import numpy as np
import pandas as pd 
import matplotlib.pyplot as plt

df = pd.read_csv("https://raw.githubusercontent.com/shstreuber/Data-Mining/master/data/amazon_toy_sample_clean.csv", encoding="ISO-8859-1")

df.head()

"""***1(a).Here By using below code we can find all the coloumns and rows in the dataset. It has 12 coloumns and 6336 rows.***"""

df.select_dtypes('O')

"""***3. I think "number of reviews" as my class attribute beacuse number of reviews depends on number of available stock and number of answer to questions. These attributes are in numeric so no need to convert them. ***

***These are the attributes that are in numeric format***
"""

df.select_dtypes('float')

df.select_dtypes('int')

"""***By using below code we can find min, max, and std, quartiles for all the attributes.***"""

df.describe(include='all')

"""***4.I have calculated 5-number summary and the standard deviation for class attribute.***"""

df.price.describe()

df.number_of_reviews.describe()

df.number_of_reviews.median()

df.number_of_reviews.mode()

"""***5.I have also calculated 5 number summary and standard deviation for other two numeric attributes***"""

df.number_available_in_stock.describe()

df.number_available_in_stock.median()

df.number_available_in_stock.mode()

df.number_of_answered_questions.describe()

df.number_of_answered_questions.median()

df.number_of_answered_questions.mode()

df1 = df.number_available_in_stock.describe()

"""# ***6.Box Plot***
***Boxplot between two attributes which are like no.of answered questions, no.of reviews.***
"""

df.boxplot(['number_of_answered_questions','number_of_reviews'])

"""***Boxplot between two attributes which are like no.of stock available, no.of reviews.***"""

df.boxplot(['number_available_in_stock','number_of_reviews'])

df.boxplot(column='number_available_in_stock',by='number_of_reviews')

"""***Basic plot for attribute number of reviews***"""

fig1, ax1 = plt.subplots()
ax1.set_title('Basic Plot')
ax1.boxplot(df.number_of_reviews)

"""#***7.Euclidian Distance***
***The distance between number of available stock and no.of reviews***
"""

point1 = np.array((df.number_available_in_stock))
point2 = np.array((df.number_of_reviews))
print("Array 1:")
print(point1)
  
print("Array 2:")
print(point2)

dist = np.linalg.norm(point1 - point2)
  
# printing Euclidean distance
print("Euclidean distance between number_available_in_stock and number_of_reviews is:", dist)

"""***The distance between number of answered questions and no.of reviews***"""

point1 = np.array((df.number_of_answered_questions))
point2 = np.array((df.number_of_reviews))
print("Array 1:")
print(point1)
  
print("Array 2:")
print(point2)

dist = np.linalg.norm(point1 - point2)
  
# printing Euclidean distance
print("Euclidean distance between number_of_answered_questions and number_of_reviews is:", dist)

"""***Basically each of the question describe something about the data set structure. I understand how to find the rows and cloumns even it is a large data. I also understand how each attribute depends on one another. By doing euclidean distance between two attributes i understand how closely one attribute depend on another.
Foe example in above dataset i have calculated distance for reviews and stock it got value of 3059 and 
also claculated for review and answered questions to product. I got value 3334. 
By this results we can assume that review is more dependent on reviews.*** 
"""

df.groupby(['status'])

df.groupby(['average_review_rating_of_5']).count()

df.groupby(['status','average_review_rating_of_5']).median()

df.dropna(inplace= True)

df2 = df.dropna(inplace = True)

df.select_dtypes('O')